{"version":3,"sources":["meteor://ðŸ’»app/packages/babrahams_transactions/lib/transactions-common.js","meteor://ðŸ’»app/packages/babrahams_transactions/lib/transactions-server.js"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,G;;;;;;;;;;;;;;;;;;ACrqDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,G","file":"/packages/babrahams_transactions.js","sourcesContent":["// *******************************\n// Transactions for Meteor + Mongo\n// by Brent Abrahams\n// brent_abrahams@yahoo.com\n// MIT Licence 2015\n// *******************************\n  \n// This package adds one new mongo collection to your app\n// It is exposed to the app via `tx.Transactions`, not via `Transactions`\n// In much the same way that we have `Meteor.users` rather than `Users`\n\nTransactions = new Mongo.Collection(Meteor.settings && Meteor.settings.transactionsCollection || \"transactions\");\n\nif (Meteor.isServer) {\n  Transactions.allow({\n    insert: function (userId, doc) { return (_.has(doc, \"items\") || doc.user_id !== userId) ? false : true; },\n    update: function (userId, doc, fields, modifier) { \n      if (userId !== doc.user_id) {\n        // TODO -- this condition will need to be modified to allow an admin to look through transactions and undo/redo them from the client\n        // That said, an admin interface shouldn't really be messing with the transactions collection from the client anyway, so ignoring this for now\n        return false;\n      }\n      else {\n        if (tx._validateModifier(modifier, doc._id)) {\n          return true;\n        }\n        else {\n          // Transactions.remove({_id:doc._id});\n          return false; \n        }\n      }\n    },\n    remove: function (userId, doc) {\n      var fullDoc = Transactions.findOne({_id: doc._id});\n      return fullDoc && fullDoc.user_id === userId;\n    }\n  });\n}\n\nTransact = function () {\n\n  // ***************************\n  // DONT OVERWRITE ANY OF THESE\n  // ***************************\n  \n  this._transaction_id = null;\n  this._autoTransaction = false;\n  this._items = [];\n  this._startAttempts = 0;\n  this._rollback = false;\n  this._rollbackReason = '';\n  this._autoCancel = null;\n  this._lastTransactionData = null;\n  this._context = {};\n  this._description = '';\n  \n  // **********************************************************************************************************\n  // YOU CAN OPTIONALLY OVERWRITE tx.collectionIndex TO MAKE THE TRANSACTIONS WORK FOR CERTAIN COLLECTIONS ONLY\n  // **********************************************************************************************************\n  \n  // e.g. in a file shared by client and server, write:\n  // tx.collectionIndex = {posts:Posts,comments:Comments, etc...}\n  // where the key is the name of the database collection (e.g. 'posts') and the value is the actual Meteor Mongo.Collection object (e.g. Posts)\n  // by default, all collections are added to tx.collectionIndex on startup in a \"Meteor.startup(function (){ Meteor.defer(function () { ...\" block\n  // so if you are planning to overwrite tx.collectionIndex, you'll also need to wrap your code in \"Meteor.startup(function (){ Meteor.defer(function () { ...\" block\n  // there's no real need to do this for most applications though\n  \n  this.collectionIndex = {};\n  \n  // ********************************************************************  \n  // YOU CAN OPTIONALLY OVERWRITE ANY OF THESE (e.g. tx.logging = false;)\n  // ********************************************************************\n\n  // Recommendations about _where_ to overwrite the following attributes/methods are given as [BOTH], [SERVER], or [CLIENT]\n\n\n  // Turn logging on or off\n  // [BOTH]\n  \n  this.logging = true;\n  \n  \n  // By default, messages are logged to the console\n  // [BOTH]\n  \n  this.log = function () { if (this.logging) { _.each(arguments, function (message) { console.log(message); }) } };\n  \n  \n  // Because most/many db writes will come through the transaction manager, this is a good place to do some permission checking\n  // NOTE: this permission check is the only thing standing between a user and the database if a transaction is committed from a method with no surrounding permission checks of its own\n  // NOTE: if you're commiting transactions from the client, you'll definitely need this as writes do not go through your allow and deny rules\n  // [BOTH]\n  \n  this.checkPermission = function (command, collection, doc, modifier) { return true; }; // commands are \"insert\", \"update\", \"remove\"\n  \n  \n  // For the purpose of filtering transactions later, a \"context\" field is added to each transaction\n  // By default, we don't do anything -- the context is empty, but there are probably certain fields in the document that we could record to use for filtering.\n  // Remember, if there are multiple document being processed by a single transaction, the values from the last document in the queue will overwrite values for fields that have taken a value from a previous document - last write wins\n  // OVERWRITING THIS WITH tx.makeContext = function () { ... } IS STRONGLY RECOMMENDED\n  // [BOTH]\n  \n  this.makeContext = function (command, collection, doc, modifier) { return {}; }; // TODO -- detect routes and add the path to the context automatically\n  \n  \n  // If requireUser is set to false, any non-logged in user, using the `babrahams:undo-redo` package gets the undo-redo stack of any non-logged-in user\n  // For security purposes this should always be set to true in real apps that use the `babrahams:undo-redo` package\n  // [BOTH]\n  \n  this.requireUser = false;\n  \n  \n  // This function is called on the client when the user tries to undo (or redo) a transaction in which some (or all) documents have been altered by a later transaction\n  // [CLIENT]\n  \n  this.onTransactionExpired = function () { alert('Sorry. Other edits have been made, so this action can no longer be reversed.'); };\n  \n  \n  // If app code forgets to close a transaction on the server, it will autoclose after the following number of milliseconds\n  // If a transaction is open on the client, it just stays open indefinitely\n  // [BOTH]\n  \n  this.idleTimeout = 5000;\n  \n  \n  // By default, documents are hard deleted and a snapshot of the document the moment before deletion is stored for retrieval in the transaction document\n  // This is much more prone to causing bugs and weirdness in apps, e.g. if a removed doc is restored after documents it depends on have been removed\n  // (and whose removal should normally have caused the restored doc to have also been removed and tagged with the same transaction_id)\n  // It's safer to turn softDelete on for complex apps, but having it off makes this package work out of the box better, as the user doesn't have to\n  // use `,deleted:{$exists:false}` in their `find` and `findOne` selectors to keep deleted docs out of the result\n  // [BOTH]\n  \n  this.softDelete = false;\n  \n  \n  // This flag tells the package how to deal with incomplete transactions, undos and redos on startup\n  // The possible modes are:\n  // `complete` - which will try to complete any pending transactions\n  // `rollback` - which will try to restore db to state prior to the pending transaction\n  // any other value will just leave the db in the state it was left at last shutdown\n  // [SERVER]\n  \n  this.selfRepairMode = 'complete';\n  \n  \n  // If you want to limit the volume of rubbish in the transactions collection\n  // you can set `tx.removeRolledBackTransactions = true`\n  // It is false by default because having a record in the db helps with debugging\n  // [BOTH]\n  \n  this.removeRolledBackTransactions = false;\n  \n  \n  // Functions to work out the inverse operation that will reverse a single collection update command.\n  // This default implementation attempts to reverse individual array $set and $addToSet operations with\n  // corresponding $pull operations, but this may not work in some cases, eg:\n  // 1.  if a $set operation does nothing because the value is already in the array, the inverse $pull will remove that value freom the array, even though\n  //     it was there before the $set action\n  // 2.  if a $addToSet operation had a $each qualifier (to add multiple values), the default inverse $pull operation will fail because $each is not suported for $pull operations\n  // \n  // You may wish to provide your own implementations that override some of these functions to address these issues if they affect your own application.\n  // For example, store the entire state of the array being mutated by a $set / $addToSet or $pull operation, and then restore it using a inverse $set operation.\n  // The tx.inverse function is called with the tx object as the `this` data context.\n  // [BOTH]\n  \n  this.inverseOperations = {\n    '$set': this._inverseUsingSet,\n    '$addToSet': function (collection, existingDoc, updateMap, opt) {\n      // Inverse of $addToSet is $pull.\n\t  // TODO -- not really -- if an element is already present, this will pull it\n\t  // out after an undo, leaving the value changed\n      // This will not work if $addToSet uses modifiers like $each.\n      // In that case, you need to restore state of original array using $set\n      return {command: '$pull', data: updateMap};\n    },\n    '$unset': this._inverseUsingSet,\n    '$pull': function (collection, existingDoc, updateMap, opt) {\n      // Inverse of $pull is $addToSet.\n\t  // TODO -- same problem as $addToSet above, but in reverse\n      return {command: '$addToSet', data: updateMap};\n    },\n    '$inc': this._inverseUsingSet,\n    '$push': function (collection, existingDoc, updateMap, opt) {\n      // Inverse of $push is $pull.\n      // This will not work if $push uses modifiers like $each, or if pushed value has duplicates in same array (because $pull will remove all instances of that value).\n      // In that case, you need to restore state of original array using $set\n      return {command: '$pull', data: updateMap};\n    },\n  };\n\n}\n\n// **********\n// PUBLIC API\n// **********\n\n// Either use these methods together on the client, or use them together on the server, but don't try mixing the two!\n\n/**\n *  Starts a transaction\n */\n\nTransact.prototype.start = function (description, options) {\n  if (tx.requireUser && !Meteor.userId()) {\n    this.log('User must be logged in to start a transaction.');\n    this._cleanReset();\n    return;\n  }\n  this._resetAutoCancel();\n  if (!this._transaction_id) {\n    \n    // Set transaction description \n    if (typeof description === 'undefined') {\n      description = 'last action';  \n    }\n    this._description = description;\n    \n    // Set any transaction options e.g. context\n    if (typeof options === 'object') {\n      if ('context' in options) this._setContext(options['context']);\n    }\n    \n    this._transaction_id = Random.id(); // Transactions.insert({user_id:Meteor.userId(),timestamp:(ServerTime.date()).getTime(),description:description});\n    this.log('Started \"' + description + '\" with transaction_id: ' + this._transaction_id + ((this._autoTransaction) ? ' (auto started)' : ''));\n    return this._transaction_id;\n  }\n  else {\n    this.log('An attempt to start a transaction (\"' + description + '\") was made when a transaction was already open. Open transaction_id: ' + this._transaction_id);\n    this._startAttempts++;\n    return false;    \n  }\n}\n\n/**\n *  Checks whether a transaction is already started\n */\n\nTransact.prototype.transactionStarted = function () {\n  return this._transaction_id || null;\n}\n\n/**\n * Commits all the changes (actions) queued in the current transaction\n */\n\nTransact.prototype.commit = function (txid, callback, newId) {\n  var self = this;\n  if (tx.requireUser && !Meteor.userId()) {\n    this.log('User must be logged in to commit a transaction.');\n    this._callback(txid, callback, new Meteor.Error('user-required','No user logged in.'), false);\n    return;\n  }\n  this._lastTransactionData = {};\n  this._lastTransactionData.transaction_id = this._transaction_id;\n  if (!this._transaction_id) {\n    this._cleanReset();\n    this.log(\"Commit reset transaction to clean state\");\n    this._callback(txid, callback, new Meteor.Error('no-transactions-open','No transaction open.'), false);\n    return;    \n  }\n  if (!_.isFunction(txid) && typeof txid !== 'undefined' && txid !== this._transaction_id && _.isString(txid)) {\n    if (txid === null) {\n      this.log(\"Forced commit\");\n    }\n    else {\n      this._startAttempts--;\n      this._callback(txid, callback, new Meteor.Error('multiple-transactions-open', 'More than one transaction open. Closing one now to leave ' + this._startAttempts + ' transactions open.'), false);\n      return;\n    }\n  }\n  if (this._startAttempts > 0 && !(!_.isFunction(txid) && typeof txid !== 'undefined' && (txid === this._transaction_id || txid === null))) {\n    this._startAttempts--;\n    this._callback(txid, callback, new Meteor.Error('multiple-transactions-open', 'More than one transaction open. Closing one now to leave ' + this._startAttempts + ' transactions open.'), false);\n    return;    \n  }\n  if (_.isEmpty(this._items)) {\n    // Don't record the transaction if nothing happened\n    // Transactions.remove({_id:this._transaction_id});\n    this.log('Empty transaction: ' + this._transaction_id);\n  }\n  if (this._rollback) {\n    // One or more permissions failed or the transaction was cancelled, don't process the execution stack\n    var error = this._rollbackReason;\n    var errorDescription = '';\n    switch (this._rollbackReason) {\n      case 'permission-denied' :\n        errorDescription = 'One or more permissions were denied, so transaction was rolled back.';\n        break;\n      case 'transaction-cancelled' :\n        errorDescription = 'The transaction was cancelled programatically, so it was rolled back.';\n        break;\n      default :\n        errorDescription = 'An error occurred when processing an action.';\n        suppressError = false;\n        break;\n    }\n    this.rollback();\n    this._callback(txid, callback, new Meteor.Error(error, errorDescription), false);\n    return;\n  }\n  else {\n    this.log('Beginning commit with transaction_id: ' + this._transaction_id);\n    var doRollback = function (err) { \n      self.log(\"Rolling back changes\");\n      self.rollback();\n      self._callback(txid, callback, new Meteor.Error('error','An error occurred, so transaction was rolled back.', err), false);    \n    }\n    try {\n      var runCallback = function (res) {\n        if (!self._lastTransactionData) {\n          self._lastTransactionData = {};    \n        }\n        self._lastTransactionData.transaction_id = self._transaction_id;\n        self._lastTransactionData.writes = res.items;\n        var newIds = _.reduce(res.items, function (memo, item) {\n          if (item.action === 'insert') {\n            if (typeof memo[item.collection] === \"undefined\") {\n              memo[item.collection] = [];  \n            }\n            memo[item.collection].push(item._id);\n          }\n          return memo;\n        }, {});\n        self._cleanReset();\n        self.log(\"Commit reset transaction manager to clean state\");\n        self._callback(txid, callback, null, newIds || true);\n      }\n      // This will be async in the client and syncronous on the server\n      if (Meteor.isServer) {\n        var cannotOverridePermissionCheck = false;\n        try {\n          var result = self._processTransaction(this._transaction_id, this._description, this._items, this._context, cannotOverridePermissionCheck);\n        }\n        catch (err) {\n          // self.log(err);\n        }\n        if (!result) {\n          self._callback(txid, callback, new Meteor.Error('error','An error occurred, so transaction was rolled back.'), false);\n          return;\n        }\n        runCallback(result);\n      }\n      else {\n        Meteor.call(\"_meteorTransactionsProcess\", this._transaction_id, this._description, this._items, this._context, function (err, res) {\n          if (err || !res) {\n            if (err) {\n              // self.log(err);\n            }\n            self._callback(txid, callback, new Meteor.Error('error','An error occurred, so transaction was rolled back.', err), false);\n            return;\n          }\n          else {\n            if (Meteor.isClient) {\n              Tracker.flush(); // Note sure about this\n            }\n            runCallback(res);\n          }\n        });\n      }\n      /*Transactions.update({_id:this._transaction_id}, {$set:_.extend({context:this._context}, {items:this._items})});*/\n    }\n    catch (err) {\n      this.log(err);\n      doRollback(err);\n      return; \n    }\n  }\n  return true; // A flag that at least the call was made\n  // Only the callback from the _meteorTransactionsProcess will really be able to tell us the result of this call\n}\n\n/**\n * Allows programmatic call of a rollback\n */\n\nTransact.prototype.rollback = function (rollbackAllDoneItems) {\n  // Need to undo all the instant stuff that's been done\n  // TODO -- this is pretty half-baked -- we should be checking that actions are actually completed before continuing -- not just watching for errors\n  // Eventually, this should be rolled into a single universal function\n  // that iterates over the items array and makes db writes\n  var self = this;\n  var items = this._items.reverse();\n  var error = false;\n  if (Meteor.isClient) {\n    // Don't let people mess with this from the client\n    // Only the server can call tx.rollback(true);\n    rollbackAllDoneItems = false;  \n  }\n  _.each(items, function (obj, index) {\n    if (obj.action === \"remove\") {\n      if ((obj.instant || rollbackAllDoneItems) && obj.state === 'done') {\n        try {\n          if (obj.doc) {\n            // This was removed from the collection, we need to reinsert it\n            tx.collectionIndex[obj.collection].insert(obj.doc);\n          }\n          else {\n            // This was soft deleted, we need to remove the deleted field\n            tx.collectionIndex[obj.collection].update({_id: obj._id}, {$unset: {deleted: 1, transaction_id: self._transaction_id}});\n          }\n          self.log('Rolled back remove');\n        }\n        catch (err) {\n          self.log(err);\n          error = true;\n        }\n      }\n    }\n    if (obj.action === \"update\") {\n      if (((obj.instant || rollbackAllDoneItems) && obj.state === 'done') && typeof obj.inverse !== 'undefined' && obj.inverse.command && obj.inverse.data) {\n        var operation = {};\n        operation[obj.inverse.command] = self._unpackageForUpdate(obj.inverse.data); // console.log(operation);\n        try {  \n          tx.collectionIndex[obj.collection].update({_id: obj._id}, operation);\n          self.log('Rolled back update');\n        }\n        catch (err) {\n          self.log(err);\n          error = true;\n        }\n      }\n    }\n    if (obj.action === \"insert\") {\n      if ((obj.instant || rollbackAllDoneItems) && obj.state === 'done') {\n        var sel = {_id: obj._id};\n        // This transaction_id check is in case the document has been subsequently edited -- in that case, we don't want it removed from the database completely\n        sel.transaction_id = self._transaction_id;\n        try {\n          tx.collectionIndex[obj.collection].remove(sel);\n          self.log('Rolled back insert');\n        }\n        catch (err) {\n          self.log(err);\n          error = true;\n        }\n      }\n    }\n    if (!error) {\n      self._changeItemState({\n        txid: self._transaction_id,\n        index: (items.length - 1) - index, // Because order was reversed for rollback\n        state: \"rolledBack\"\n      });\n    }\n  });\n  if (error) {\n    this.log(\"Rollback failed -- you'll need to check your database manually for corrupted records.\");\n    this.log(\"Here is a log of the actions that were tried and their inverses:\");\n    this.log(\"(it was probably one of the inverse actions that caused the problem here)\");\n    this.log(EJSON.stringify(items, null, 2));    \n  }\n  if (tx.removeRolledBackTransactions) {\n    if (rollbackAllDoneItems) {\n      Transactions.remove({_id: this._transaction_id});\n    }\n    this.log('Incomplete transaction removed: ' + this._transaction_id);\n  }\n  else {\n    if (!Transactions.findOne({_id: this._transaction_id})) {\n      var transactionRecord = {_id: this._transaction_id, user_id: tx._userOrNull(), description: this._description, items: items, context: this._context, lastModified: ServerTime.date(), state: \"rolledBack\"};\n      Transactions.insert(transactionRecord, function (err, res) {\n        if (err) {\n          self.log('No record of transaction:', self._transaction_id);    \n        }\n      });\n    }\n    else {\n      Transactions.update({_id: this._transaction_id}, {$set: {state: \"rolledBack\"}});\n    }\n  }\n  self._cleanReset();\n  this.log(\"Rollback reset transaction manager to clean state\");\n}\n\n/**\n * Queue an insert\n */\n\nTransact.prototype.insert = function (collection, newDoc, opt, callback) {\n  if (this._rollback || (tx.requireUser && !Meteor.userId())) {\n    return;    \n  }\n  // We need to pass the options object when we do the actual insert\n  // But also need to identify any callback functions\n  var callback = (_.isFunction(callback)) ? callback : ((typeof opt !== 'undefined') ? ((_.isFunction(opt)) ? opt : ((_.isFunction(opt.callback)) ? opt.callback : undefined)) : undefined);\n  if (opt && _.isObject(opt.tx)) {\n    opt = opt.tx;\n  }\n  opt = (_.isObject(opt)) ? _.omit(opt,'tx') : undefined; // This is in case we're going to pass this options object on to, say, collection2 (tx must be gone or we'll create an infinite loop)\n  // NOTE: \"collection\" is the collection object itself, not a string\n  if (this._permissionCheckOverridden(opt) || this._permissionCheck(\"insert\", collection, newDoc, {})) {\n    var self = this;\n    this._openAutoTransaction(opt && opt.description || 'add ' + collection._name.slice(0, - 1));\n    self._setContext((opt && opt.context) || self.makeContext('insert', collection, newDoc, {}));\n    if ((typeof opt !== 'undefined' && opt.instant)) { // || this._autoTransaction\n      try {\n        var newId = newDoc._id || Random.id();\n        var newDoc = _.extend(newDoc, {_id: newId, transaction_id: self._transaction_id});\n        var newId = self._doInsert(collection, newDoc, opt, callback); // Should give the same newId value as the one we passed\n        var item = self._createItem('insert', collection, newId, {doc: newDoc}, true, self._permissionCheckOverridden(opt));\n        this._recordTransaction(item);\n        self._pushToRecord(\"insert\", collection, newId, {doc: newDoc}, true, self._permissionCheckOverridden(opt)); // true is to mark this as an instant change\n        this._closeAutoTransaction(opt, callback, newId);\n        this.log(\"Executed instant insert\");\n        return newId;\n      }\n      catch(err) {\n        this.log(err);\n        this.log(\"Rollback initiated by instant insert command\");\n        this._rollback = true;\n        this._rollbackReason = 'insert-error';\n      }\n    }\n    var newId = newDoc._id || Random.id();\n    // var newId = self._doInsert(collection,_.extend(newDoc,{transaction_id:self._transaction_id}),opt,callback);\n    self._pushToRecord(\"insert\", collection, newId, {doc: _.extend(newDoc, {_id: newId, transaction_id: self._transaction_id})}, false, self._permissionCheckOverridden(opt));\n    this.log(\"Pushed insert command to stack: \" + this._transaction_id); //  + ' (Auto: ' + this._autoTransaction + ')'\n    this._closeAutoTransaction(opt, callback);\n    return newId;\n  }\n  else {\n    this._rollback = true;\n    this._rollbackReason = 'permission-denied';\n    this.log(\"Insufficient permissions to insert this document into \" + collection._name + ':', newDoc); // Permission to insert not granted\n    return;    \n  }\n  \n}\n\n/**\n * Queue a remove\n */\n\nTransact.prototype.remove = function (collection, doc, opt, callback) {\n  // Remove any document with a field that has this val\n  // NOTE: \"collection\" is the collection object itself, not a string\n  if (this._rollback || (tx.requireUser && !Meteor.userId())) {\n    return;    \n  }\n  // We need to pass the options object when we do the actual remove\n  // But also need to identify any callback functions\n  var callback = (_.isFunction(callback)) ? callback : ((typeof opt !== 'undefined') ? ((_.isFunction(opt)) ? opt : ((_.isFunction(opt.callback)) ? opt.callback : undefined)) : undefined);\n  if (opt && _.isObject(opt.tx)) {\n    opt = opt.tx;\n  }\n  var _id = (_.isObject(doc)) ? doc._id : doc;\n  var existingDoc = collection.findOne({_id: _id}); // (!_.isObject(doc)) ? collection.findOne({_id: doc}) : doc; // , {transform: null}\n  if (!(_id && existingDoc)) {\n    tx.log('No document found. Make sure you provide an _id field for a document that exists. You passed: ' + JSON.stringify(doc));\n  }\n  if (this._permissionCheckOverridden(opt) || this._permissionCheck(\"remove\", collection, existingDoc, {})) {\n    var self = this;\n    this._openAutoTransaction(opt && opt.description || 'remove ' + collection._name.slice(0, - 1));\n    var sel = {_id: _id};\n    if (Meteor.isServer) {\n      sel.deleted = {$exists: false}; // Can only do removes on client using a simple _id selector\n    }\n    self._setContext((opt && opt.context) || self.makeContext('remove', collection, existingDoc, {}));\n    if (opt && opt.instant) {\n      try {\n        self._doRemove(collection, _id, sel, true, opt, callback);\n        this.log(\"Executed instant remove\");\n      }\n      catch(err) {\n        this.log(err);\n        this.log(\"Rollback initiated by instant remove command\");\n        this._rollback = true;\n        this._rollbackReason = 'remove-error';\n      }\n    }\n    else {\n      self._doRemove(collection, _id, sel, false, opt, callback);\n      this.log(\"Pushed remove command to stack: \" + this._transaction_id); //  + ' (Auto: ' + this._autoTransaction + ')'\n    }\n    this._closeAutoTransaction(opt, callback);\n    return !this._rollback; // Remove was executed or queued for execution\n  }\n  else {\n    this._rollback = true;\n    this._rollbackReason = 'permission-denied';\n    this.log(\"Insufficient permissions to remove this document from \" + collection._name + ':', existingDoc); // Permission to remove not granted\n    return;\n  }\n}\n\n/**\n * Queue an update\n */\n\nTransact.prototype.update = function (collection, doc, updates, opt, callback) {\n  // NOTE: \"field\" should be of the form {$set:{field:value}}, etc.\n  // NOTE: \"collection\" is the collection object itself, not a string\n  if (this._rollback || (tx.requireUser && !Meteor.userId())) {\n    return;    \n  }\n  // We need to pass the options object when we do the actual update\n  // But also need to identify any callback functions\n  var callback = (_.isFunction(callback)) ? callback : ((typeof opt !== 'undefined') ? ((_.isFunction(opt)) ? opt : ((_.isFunction(opt.callback)) ? opt.callback : undefined)) : undefined);\n  if (opt && _.isObject(opt.tx)) {\n    opt = opt.tx;\n  }\n  var opt = (_.isObject(opt)) ? _.omit(opt,'tx') : undefined;\n  var self = this;\n  var _id = (_.isObject(doc)) ? doc._id : doc;\n  var existingDoc = collection.findOne({_id: _id}); // , {transform: null}\n  // var existingDoc = (!_.isObject(doc)) ? collection.findOne({_id:_id}) : doc;\n  // the above is slightly more efficient, in that it doesn't hit the database again\n  // but potential buggy behaviour if a partial doc is passed and the field being updated\n  // isn't in it and it's a $set command and so the inverse is wrongly taken to be $unset\n  if (!(_id && existingDoc)) {\n    tx.log('No document found. Make sure you provide an _id field for a document that exists. You passed: ' + JSON.stringify(doc)); \n  }\n  if (this._permissionCheckOverridden(opt) || this._permissionCheck(\"update\", collection, existingDoc, updates)) {\n    this._openAutoTransaction(opt && opt.description || 'update ' + collection._name.slice(0, - 1));\n    var actionFields = _.pairs(updates); // console.log('actionFields:', actionFields);\n    // If the command is $set, the update map needs to be split into individual fields in case some didn't exist before and some did\n    // in which case different fields will require different inverse operations\n    actionFields = _.reduce(actionFields, function (memo, action) {\n      var command = action[0]; // console.log(\"the command:\", command);\n      var updateMap = action[1]; // console.log(\"the map:\", updateMap);\n      if (command === '$set') {\n        actions = _.map(updateMap, function (val, key) {\n          var obj = {};\n          obj[key] = val;\n          return obj;\n        }); // console.log(\"the actions:\", actions);\n      }\n      else {\n        actions = [updateMap];  \n      }\n      _.each(actions, function (update) {\n        memo.push([command, update]);\n      });\n      return memo;\n    }, []); // console.log(\"actionFields:\", actionFields);\n    var actionFieldsCount = actionFields.length;\n    for (var i = 0; i < actionFieldsCount; i++) {\n      var command = actionFields[i][0]; // console.log(\"command:\", command);\n      var updateMap = actionFields[i][1]; // console.log(\"updateMap:\", updateMap, EJSON.stringify(updateMap));\n      var inverse;\n      if (typeof opt === 'undefined' || typeof opt.inverse === 'undefined') {\n        // var fieldName = _.keys(actionField[0][1])[0]; // console.log(fieldName);\n        if (typeof opt === 'undefined') {\n          opt = {};    \n        }\n\t\t// console.log(\"inverse called with (collection, existingDoc, updateMap, opt):\", collection, existingDoc, updateMap, opt);\n        inverse = _.isFunction(this.inverseOperations[command]) && this.inverseOperations[command].call(self, collection, existingDoc, updateMap, opt) || this._inverseUsingSet(collection, existingDoc, updateMap, opt);\n\t\t// console.log(\"inverse:\", inverse);\n      }\n      else {\n        // This \"opt.inverse\" thing is only used if you need to define some tricky inverse operation, but will probably not be necessary in practice\n        // a custom value of opt.inverse needs to be an object of the form:\n        // {command: \"$set\", data: {fieldName: value}}\n        inverse = opt.inverse;    \n      }\n      // console.log(\"inverse:\", inverse);\n      self._setContext((opt && opt.context) || self.makeContext('update', collection, existingDoc, updates));\n      var updateData = {command: command, data: updateMap};\n      if (opt && opt.instant) {\n        try {      \n          self._doUpdate(collection, _id, updates, updateData, inverse, true, opt, callback, (i === (actionFieldsCount - 1)) ? true : false);\n          this.log(\"Executed instant update\"); // true param is to record this as an instant change\n        }\n        catch(err) {\n          this.log(err);\n          this.log(\"Rollback initiated by instant update command\");\n          this._rollback = true;\n          this._rollbackReason = 'update-error';\n        }\n      }\n      else {\n        (function (updateData, inverse, execute) { // console.log('updateData, inverse, execute:', updateData, inverse, execute);\n          self._doUpdate(collection, _id, updates, updateData, inverse, false, opt, callback, execute);\n          this.log(\"Pushed update command to stack: \" + this._transaction_id); //  + ' (Auto: ' + this._autoTransaction + ')'\n        }).call(this, updateData, inverse, (i === (actionFieldsCount - 1)) ? true : false);\n      }\n    }\n    this._closeAutoTransaction(opt, callback);\n    return !this._rollback; // Update was executed or queued for execution\n  }\n  else {\n    this._rollback = true;\n    this._rollbackReason = 'permission-denied';\n    this.log(\"Insufficient permissions to update this document in \" + collection._name + ':', existingDoc); // Permission to update not granted\n    return;\n  }\n}\n\n/**\n * Cancels a transaction, but doesn't roll back immediately\n * When the transaction is committed, no queued actions will be executed\n * and any instant updates, inserts or removes that were made will be rolled back\n */  \n\nTransact.prototype.cancel = function () {\n  this.log('Transaction cancelled');\n  this._rollback = true;\n  this._rollbackReason = 'transaction-cancelled';\n}\n\n/**\n * Undo the last transaction by the user\n */ \n\nTransact.prototype.undo = function (txid, callback) {\n  var self = this;\n  var callback = (_.isFunction(txid)) ? txid : callback;\n  Meteor.call(\"_meteorTransactionsUndo\", (_.isString(txid)) ? txid : null, function (err, res) {\n    if (Meteor.isClient && res && _.isFunction(self.onTransactionExpired)) {\n      self.onTransactionExpired.call(self, err, res);\n    }\n    if (_.isFunction(callback)) {\n      callback.call(self, err, !res);\n    }\n  });\n}\n\n/**\n * Redo the last transaction undone by the user\n */\n\nTransact.prototype.redo = function (txid, callback) {\n  var self = this;\n  var callback = (_.isFunction(txid)) ? txid : callback;\n  Meteor.call(\"_meteorTransactionsRedo\", (_.isString(txid)) ? txid : null, function (err, res) {\n    if (Meteor.isClient && res && _.isFunction(self.onTransactionExpired)) {\n      self.onTransactionExpired.call();  \n    }\n    if (_.isFunction(callback)) {\n      callback.call(self, err, !res);\n    }\n  });\n}\n\n/**\n * Manually add context to current transaction\n */\n \nTransact.prototype.setContext = function (context) {\n  this._setContext(context);\n}\n\n// **********************************************************\n// INTERNAL METHODS - NOT INTENDED TO BE CALLED FROM APP CODE\n// **********************************************************\n\nTransact.prototype._doInsert = function (collection, newDoc, opt, callback) {\n  // The following is a very sketchy attempt to support collection2 options\n  // Requires aldeed:collection2 to be before babrahams:transactions in .packages\n  // which we do through a weak dependency on aldeed:collection2\n  if (this._Collection2Support(collection, opt)) {\n    // This is a brutal workaround to allow collection2 options to do their work\n    var newId = null;\n    var error = null;\n    var returnedId = collection.insert(newDoc, opt, function (err, newId) {\n      if (!err) {\n        newId = newId;\n      }\n      else {\n        error = err;    \n      }\n      if (_.isFunction(callback)) { // Let the app handle the error via its own callback\n        callback(error, newId);\n      }\n    });\n    if (returnedId) {\n      return returnedId;\n    }\n    else {\n      throw new Meteor.Error('Insert failed: reason unknown.', '');  \n    }\n  }\n  else {\n    return collection.insert(newDoc, callback);\n  }\n}\n\nTransact.prototype._doRemove = function (collection, _id, sel, instant, opt, callback) {\n  if (!_.isFunction(callback)) {\n    callback = undefined;  \n  }\n  var self = this;\n  if ((opt && typeof opt.softDelete !== 'undefined' && opt.softDelete) || (opt && typeof opt.softDelete === 'undefined' && tx.softDelete) || (typeof opt === 'undefined' && tx.softDelete)) {\n    self._pushToRecord(\"remove\", collection, _id, null, instant, self._permissionCheckOverridden(opt));\n    if (instant) {\n      var item = self._createItem(\"remove\", collection, _id, null, instant, self._permissionCheckOverridden(opt));\n      self._recordTransaction(item);\n      collection.update(sel, {$set: {deleted: ServerTime.date(), transaction_id: self._transaction_id}}, callback);\n    }\n    return;\n  }\n  var fields = {hardDelete: true};\n  // Hard delete document\n  if (instant) {\n    var fullDoc = collection.findOne(sel); // , {transform: null}\n    fields.doc = fullDoc;\n    if (!fullDoc) {\n      // There is no existing document to remove\n      // Return without creating an item in the queue or recording it\n      this.log(\"Document not found for removal:\", sel);\n    }\n    else {\n      fields.doc.transaction_id = self._transaction_id;\n      fields.doc.deleted = ServerTime.date();\n    }\n    var item = self._createItem(\"remove\", collection, _id, fields, instant, self._permissionCheckOverridden(opt));\n    self._recordTransaction(item);\n    collection.remove(sel, callback);\n  }\n  self._pushToRecord(\"remove\", collection ,_id, fields, instant, self._permissionCheckOverridden(opt)); // null is for field data (only used for updates) and true is to mark this as an instant change\n}\n\nTransact.prototype._doUpdate = function (collection, _id, updates, updateData, inverseData, instant, opt, callback, execute) {\n  // console.log(\"collection, _id, updates, updateData, inverseData, instant, opt, callback, execute\", collection, _id, updates, updateData, inverseData, instant, opt, callback, execute);\n  var self = this;\n  if (instant) {\n    if (execute) {\n      if (!_.isFunction(callback)) {\n        callback = undefined;\n      }\n      if (_.isObject(updates[\"$set\"])) {\n        _.extend(updates[\"$set\"], {transaction_id: self._transaction_id});\n      }\n      else {\n        updates[\"$set\"] = {transaction_id: self._transaction_id};\n      }\n      // This error, handler business is to allow collection2 `filter:false` to do its work\n      var error = null;\n      var handler = function (err, res) {\n        if (err) {\n          error = err;  \n        }\n        if (_.isFunction(callback)) {\n          callback(err, res);\n        }\n      }\n      var item = self._createItem(\"update\", collection, _id, {update: self._packageForStorage(updateData), inverse: self._packageForStorage(inverseData)}, instant,self._permissionCheckOverridden(opt));\n      self._recordTransaction(item);\n      // No need to check for aldeed:collection2 support (like we do for inserts)\n      // as we can pass an options hash to an update\n      if (_.isObject(opt)) {\n        collection.update({_id:_id}, updates, opt, handler);\n      }\n      else {\n        collection.update({_id:_id}, updates, handler);    \n      }\n      if (error) {\n        throw new Meteor.Error('Update failed: ' + error.message, error.reason);\n        return;\n      }\n      delete updates[\"$set\"].transaction_id;\n    }\n  }\n  // console.log(JSON.stringify({update: self._packageForStorage(updateData)}), JSON.stringify({inverse: self._packageForStorage(inverseData)}));\n  self._pushToRecord(\"update\", collection, _id, {update: self._packageForStorage(updateData), inverse: self._packageForStorage(inverseData)}, instant, self._permissionCheckOverridden(opt));\n}\n\n// This is used only if an {instant: true} parameter is passed\n\nTransact.prototype._recordTransaction = function (item) {\n  if (!Transactions.findOne({_id: this._transaction_id})) {\n    // We need to get a real transaction in the database for recoverability purposes\n    var user_id = tx._userOrNull();\n    Transactions.insert({\n      _id: this._transaction_id,\n      user_id: user_id,\n      lastModified: ServerTime.date(),\n      description: this._description,\n      context: this._context,\n      state: \"pending\"\n    });\n  }\n  Transactions.update({_id: this._transaction_id}, {$addToSet: {items: item}});\n}\n\n// This is used to check that the document going into the transactions collection has all the necessary fields\n\nTransact.prototype._validateModifier = function (modifier, txid) {\n  var fields = modifier && modifier[\"$addToSet\"];\n  if (!fields) {\n   return null;\n  }\n  return this._checkTransactionFields([fields.items], txid);\n}\n\nTransact.prototype._checkTransactionFields = function (items, txid, cannotOverridePermissionCheck) {\n  // Iterate over all the items that are going to be stored on the transaction stack and check their legitimacy\n  if (!items || !items.length) {\n   return false; \n  }\n  var self = this, recombinedUpdateFields = {}, recombinedInverseFields = {};\n  var action, collection, doc, details, inverseDetails, fail = false;\n  _.each(items, function (value) {\n    if (!fail) {\n      collection = value.collection;\n      // Watch out for undo method validation of a remove, where the doc has been hard removed from the collection\n      // Allowing a doc through that was passed from the client is a potential security hole here, but without soft delete, there is no actual record of that doc\n      // So we check that the removed doc's transaction_id value matches the txid\n      if (value.action === 'remove' && value.doc && value.doc.transaction_id === txid) {\n         doc = value.doc;\n      }\n      else if (value.action === 'insert' && value.doc && value.doc.transaction_id === txid) {\n        // Handle redo of an insert (after a previous undo)\n        doc = value.doc;\n      }\n      else {\n        doc = self.collectionIndex[collection].findOne({_id: value._id});\n      }\n      if (Meteor.isClient && !doc) {\n        // Because this runs in a client simulation,\n        // where a removed document may not be in the collection\n        // or we simply may not be subscribed to that doc anymore \n        // we need to consider and watch out for this\n        // we'll extend the benefit of the doubt and let the server handle the real check\n        return;  \n      }\n      if (value.action === 'update') {\n        action = 'update';\n        details = value.update;\n        inverseDetails = value.inverse;\n        recombinedUpdateFields[details.command] = self._unpackageForUpdate(details.data);\n        recombinedInverseFields[inverseDetails.command] = self._unpackageForUpdate(inverseDetails.data);\n        if (!(value.noCheck && !cannotOverridePermissionCheck)) {\n          // Transactions that have been allowed using overridePermissionCheck are considered here, using the noCheck flag\n          // Otherwise the user won't be able to undo them\n          try {\n            fail = !(self._permissionCheck(action, self.collectionIndex[collection], doc, recombinedUpdateFields) && self._permissionCheck(action, self.collectionIndex[collection], doc, recombinedInverseFields));\n          }\n          catch (err) {\n            fail = true;\n          }\n        }\n        return;\n      }\n      else if (value.action === 'insert') {\n        action = 'insert';  \n      }\n      else if (value.action === 'remove' ) {\n        action = 'remove';   \n      }\n      if (!(value.noCheck && !cannotOverridePermissionCheck)) {\n        try {\n          fail = !self._permissionCheck(action, self.collectionIndex[collection], doc, {});\n        }\n        catch (err) {\n          // If this transaction was made possible by overridePermissionCheck\n          // It may not be undo/redo-able, unless we follow the same rules (i.e. abide by the noCheck flag)\n          fail = true;\n        }\n      }\n    }\n  });\n  return !fail;\n}\n\n// Reset everything to a clean state\n\nTransact.prototype._cleanReset = function () {\n  this._transaction_id = null;\n  this._autoTransaction = false;\n  this._items = [];\n  this._startAttempts = 0;\n  this._granted = {};\n  this._rollback = false;\n  this._rollbackReason = '';\n  this._context = {};\n  this._description = '';\n  // Note: we don't reset this._lastTransactionData because we want it to be available AFTER the commit\n  if (Meteor.isServer) {\n    Meteor.clearTimeout(this._autoCancel);\n  }\n}\n\nTransact.prototype._callback = function (a, b, err, res) {\n  var c = (_.isFunction(a)) ? a : ((_.isFunction(b)) ? b : null);\n  if (c) {\n    c.call(this._lastTransactionData, err, res);\n  }  \n}\n\n// Starts a transaction automatically if one isn't started already\n\nTransact.prototype._openAutoTransaction = function (description) {// console.log(\"Auto open check value for transaction_id: \" + this._transaction_id + ' (Auto: ' + this._autoTransaction + ')');\n  if (!this._transaction_id) {\n    this._autoTransaction = true;\n    this._description = description;\n    this.start(description);\n    // console.log(\"Auto opened: \" + this._transaction_id + ' (Auto: ' + this._autoTransaction + ')');\n  }\n}\n\n// Commits a transaction automatically if it was started automatically\n\nTransact.prototype._closeAutoTransaction = function (opt, callback, newId) {// console.log(\"Auto commit check value for autoTransaction: \" + this._autoTransaction + ' (Auto: ' + this._autoTransaction + ')');\n  if (this._autoTransaction) {\n    this.log(\"Auto committed: \" + this._transaction_id); // + ' (Auto: ' + this._autoTransaction + ')';\n    this.commit(opt, undefined, newId);\n  }\n}\n\n// Cancels and commits a transaction automatically if it exceeds the idleTimeout threshold with no new actions\n\nTransact.prototype._resetAutoCancel = function () {\n  if (Meteor.isServer) {\n    var self = this;\n    Meteor.clearTimeout(this._autoCancel);\n    this._autoCancel = Meteor.setTimeout(function () {\n      self.log('Transaction (' + self._transaction_id + ') was cancelled after being inactive for ' + (self.idleTimeout / 1000) + ' seconds.');\n      self.rollback();\n    },this.idleTimeout);\n  }\n  else {\n    // TODO -- find a way to cancel idle transactions on the client  \n  }\n}\n\n// Pushes the record of a single action to the \"items\" sub document that is going to be recorded in the transactions collection along with data about this transaction\n\nTransact.prototype._pushToRecord = function (type, collection, _id, fieldData, instant, permissionCheckOverridden) {\n  var item = this._createItem(type, collection, _id, fieldData, instant, permissionCheckOverridden);\n  this._items.push(item);\n  this._resetAutoCancel();\n}\n\n// Create item for queue\n\nTransact.prototype._createItem = function (type, collection, _id, fieldData, instant, permissionCheckOverridden) {\n  var item = {collection:collection._name, _id:_id, action:type, state: \"pending\"};\n  if (typeof instant !== 'undefined' && instant) {\n    item.instant = true;\n    item.state = \"done\";\n  }\n  if (typeof permissionCheckOverridden !== 'undefined' && permissionCheckOverridden) {\n    item.noCheck = true;  \n  }\n  if (typeof fieldData !== \"undefined\" && fieldData) {\n    _.extend(item, fieldData);    \n  }\n  return item;\n}\n\n// Checks whether the permission check should be waived\n\nTransact.prototype._permissionCheckOverridden = function (opt) {\n  return typeof opt !== 'undefined' && opt.overridePermissionCheck;\n}\n\n// Uses a user-defined permission check as to whether this action is allowed or not\n\nTransact.prototype._permissionCheck = function (action, collection, doc, updates) { // insert and remove send null for \"updates\" param, but this is where all the details of any update are found\n  return this.checkPermission(action, collection, doc, updates);\n}\n\n// Builds the context object\n\nTransact.prototype._setContext = function (context) {\n  _.extend(this._context, context);  \n}\n\n// This turns the data that has been stored in an array of key-value pairs into an object that mongo can use in an update\n\nTransact.prototype._unpackageForUpdate = function (data) {\n  var objForUpdate = {};\n  _.each(data, function (val) {\n    var unpackagedValue;\n    if (val.json) {\n      unpackagedValue = EJSON.parse(val.json);\n    }\n    else {\n      unpackagedValue = val.value;\n    }\n    objForUpdate[val.key] = unpackagedValue;\n  });\n  return objForUpdate;\n}\n\n// This turns the data that is given as a mongo update into an array of key-value pairs that can be stored\n  \nTransact.prototype._packageForStorage = function (update) {\n  var arrForStorage = [];\n  _.each(update.data, function (value, key) {\n    var packagedValue = {};\n    if ((_.isObject(value) || _.isArray(value)) && !_.isDate(value)) { // a date is considered an object by _.isObject (because it is, I suppose)\n      packagedValue.json = EJSON.stringify(value);\n    }\n    else {\n      packagedValue.value = value;\n    }\n    arrForStorage.push(_.extend({key: key}, packagedValue));\n  });\n  return {command: update.command, data: arrForStorage};\n  \n}\n\n// Given a dot delimited string as a key, and an object, find the value\n\nTransact.prototype._drillDown = function (obj, key) {\n  return Meteor._get.apply(null, [obj].concat(key.split('.')));\n  // Previous implementation, which worked fine but was more LOC than necessary\n  /*var pieces = key.split('.');\n  if (pieces.length > 1) {\n    var newObj = obj ? obj[pieces[0]] : {};\n    pieces.shift();\n    return this._drillDown(newObj,pieces.join('.'));\n  }\n  else {\n    if (obj) {\n      return obj[key];\n    }\n    else {\n      return; // undefined    \n    }    \n  }*/\n}\n\n// Default inverse operation that uses $set to restore original state of updated fields\n\nTransact.prototype._inverseUsingSet = function (collection, existingDoc, updateMap, opt) {\n  var self = this, inverseCommand = '$set', formerValues = {};\n  _.each(_.keys(updateMap), function (keyName) {\n    var formerVal = self._drillDown(existingDoc || {}, keyName);\n    if (typeof formerVal !== 'undefined') {\n      // Restore former value\n      inverseCommand = '$set';\n      formerValues[keyName] = formerVal;\n    }\n    else {\n      // Field was already unset, so just $unset it again\n      inverseCommand = '$unset';\n      formerValues[keyName] = 1;\n    }\n  });\n  return {command: inverseCommand, data: formerValues};\n};\n\nTransact.prototype._Collection2Support = function (collection, opt) {\n  // The following is a very sketchy attempt to support collection2 options\n  // Requires aldeed:collection2 to be before babrahams:transactions in .packages\n  // which we do through a weak dependency on aldeed:collection2\n  return _.isFunction(collection.simpleSchema)\n    && collection.simpleSchema() !== null\n    && _.find([\n      \"validationContext\",\n      \"validate\",\n      \"filter\",\n      \"autoConvert\",\n      \"removeEmptyStrings\",\n      \"getAutoValues\",\n      \"replace\",\n      \"upsert\",\n      \"extendAutoValueContext\",\n      \"trimStrings\",\n      \"extendedCustomContext\",\n      \"transform\"\n    ],\n    function (c2option) {\n      return typeof opt[c2option] !== \"undefined\";\n    }\n  );\n}\n\nTransact.prototype._changeItemState = function (data) {\n  \n  // Need to make a write to the transaction record, marking this action as `done`\n  var m = {};\n  m[\"items.\" + data.index + \".state\"] = data.state;\n  Transactions.update({_id: data.txid}, {$set: m});\n  \n}\n\nTransact.prototype._userOrNull = function () {\n  var userId = null;\n  // Need the try-catch because we don't know if this is getting called from a method or from plain server code\n  // If from plain server code, it will throw an error\n  try {\n    userId = _.isFunction(Meteor.userId) && Meteor.userId();\n  }\n  catch (err) {\n    return null;  \n  }\n  return userId;\n}\n\n/**\n *  Actually execute the transaction - i.e. make the db writes\n */\n\nTransact.prototype._processTransaction = function (txid, description, items, context, cannotOverridePermissionCheck) {\n\n  check(txid,String);\n  check(description,String);\n  check(items, Array);\n  check(context, Object);\n  check(cannotOverridePermissionCheck, Boolean); \n  \n  if (items && items.length && !tx._checkTransactionFields(items, txid, cannotOverridePermissionCheck)) {\n    throw new Meteor.Error('Transaction not allowed'); // TODO -- we need a bit of a better error message than this!\n    return; \n  }\n  // Here is where we need to execute the 2-phase commit\n  // We begin by setting the transaction document with all write info to a state of pending\n  var existingTransaction = Transactions.findOne({_id: txid});\n  if (existingTransaction) {\n    // throw new Meteor.Error('Transaction with duplicate _id found');\n    // return;\n    // This is here because we have some {instant: true} calls\n    // Overwrite the items field with the full complement\n    Transactions.update({_id: txid}, {$set: {items: items}});\n  }\n  \n  // First, need to iterate over the changes that are going to be made and make sure that,\n  // if there are hard removes, the db version of the doc gets stored on the transaction\n  _.each(items, function (item, index) {\n    if (item.action === \"remove\" && item.hardDelete) {\n      // Get the existing doc and store it in the transaction record\n      // We overwrite the temporary version of the doc from an instant remove on the client\n      // Because chances are that the whole document was not available on the client\n      var Collection = tx.collectionIndex[item.collection];\n      var doc = Collection.findOne({_id: item._id}); // , {transform: null}\n      items[index].doc = doc;\n    }\n  });\n  \n  // STEP 1 - Set initial state of transaction to \"pending\"\n\n   if (!existingTransaction && !Transactions.insert({_id: txid, user_id: tx._userOrNull(), description: description, items: items, context: context, lastModified: ServerTime.date(), state: \"pending\"})) {\n     throw new Meteor.Error('Unable to commit transaction');\n     return; \n   }\n  \n  // STEP 2 - Make changes specified by items in the queue\n  var success = true;\n  var logErrors = function (err) {\n    console.log(err.toString());\n  };\n  var updateCache = {};\n  var cacheValues = function (item, index) {\n    _.each(item.update.data, function (keyValuePair, i) {\n      if (_.isUndefined(updateCache[item.collection])) {\n        updateCache[item.collection] = {};\n      }\n      if (_.isUndefined(updateCache[item.collection][item._id])) {\n        updateCache[item.collection][item._id] = {};\n      }\n      // If there's an item in the update cache, we need to overwrite the transaction record now\n      // Because we know it probably has the wrong inverse value\n      if (!_.isUndefined(updateCache[item.collection][item._id][keyValuePair.key])) {\n        var mod = tx._unpackageForUpdate([{\n          key: \"items.\" + index + \".inverse.data.\" + i + \".value\",\n          value: updateCache[item.collection][item._id][keyValuePair.key]\n        }]);\n        var update = {$set: mod};\n        if (cannotOverridePermissionCheck) {\n          update[\"$unset\"] = {noCheck: 1};\n        }\n        Transactions.update({_id: txid}, update);          \n      }\n      updateCache[item.collection][item._id][keyValuePair.key] = keyValuePair.value;\n    });\n  }\n  var newIdValues = {};\n  _.each(items, function (item, index) {\n    if (success) {\n      try {\n        if (item.instant) {\n          // Already done -- don't do it again\n          if (item.action === 'update') {\n             // Cache values\n             cacheValues(item, index);\n          }\n          return;    \n        }\n        var Collection = tx.collectionIndex[item.collection];\n        var txData = {transaction_id: txid};\n        switch (item.action) {\n          case 'insert' :\n            // Will run synchronously. If this fails an exception will be thrown\n            var newId = Collection.insert(_.extend(item.doc, {_id: item._id}, txData));\n\n            // The insert succeeded\n            items[index].state = 'done';\n            tx.log(\"Executed insert\");\n\n\n            break;\n          case 'update' :\n            var modifier = {};\n            var data = tx._unpackageForUpdate(item.update.data);\n            modifier[item.update.command] = data;\n            if (modifier[\"$set\"]) {\n              // Add to the $set modifier\n              modifier[\"$set\"] = _.extend(modifier[\"$set\"], txData);\n            }\n            else {\n              // Add a $set modifier\n              modifier[\"$set\"] = txData;\n            }\n\n            // Will run synchronously. If this fails an exception will be thrown\n            Collection.update({_id: item._id}, modifier);\n\n            // The update succeeded\n            // Cache values\n            if (item.update.command === \"$set\") {\n              cacheValues(item, index);\n            }\n            items[index].state = 'done';\n            tx.log(\"Executed update\");\n\n            break;\n          case 'remove' :\n            if (item.hardDelete) {\n\n              // Remove the whole document\n              // Will run synchronously. If this fails an exception will be thrown\n              var removed = Collection.remove({_id: item._id});\n\n              // The remove succeeded\n              items[index].state = 'done';\n              tx.log('Executed remove');\n            }\n            else {\n              // Just do a soft delete\n              // Will run synchronously. If this fails an exception will be thrown\n              Collection.update({_id: item._id}, {$set: _.extend(txData, {deleted: ServerTime.date()})});\n\n              // The remove succeeded\n              items[index].state = 'done';\n              tx.log('Executed remove');\n\n            }\n            break;\n          default :\n            // Do nothing\n        }\n      }\n      catch (err) {\n        if (err) {\n          success = false;\n          logErrors(err);  \n        }\n      }\n    }\n    \n    if (success) {\n      tx._changeItemState({\n        txid: txid,\n        index: index,\n        state: 'done'\n      });\n    }\n    \n  });\n    \n  // STEP 3 - Set state to \"done\"\n  if (success) {\n    Transactions.update({_id: txid}, {$set: {state: \"done\", lastModified: ServerTime.date()}}, function (err, res) {\n      if (err) {\n        console.log('Could not complete transaction:', txid, err);\n        success = false;    \n      }\n    });\n    if (success) {\n      var finalTxRecord = Transactions.findOne({_id: txid});\n      return {items: finalTxRecord.items};\n    }\n  }\n  else {\n    tx.log('Transaction failed');\n    // Need to run the items through a rollback with actual inverse writes\n    var rollbackAllDoneItems = true;\n    tx._transaction_id = txid;\n    tx._items = items;\n    tx._description = description;\n    tx._context = context;\n    tx.rollback.call(tx, rollbackAllDoneItems);\n  }\n        \n}\n\n\n// ******************************\n// Instantiation of the tx object\n// ******************************\n\n// This (tx) is the object that gets exported for the app to interact with\n\nif (typeof tx === 'undefined') {\n  tx = new Transact();\n  tx.Transactions = Transactions; // Expose the Transactions collection via tx\n}\nelse {\n  throw new Meteor.Error('`tx` is already defined in the global scope. The babrahams:transactions package won\\'t work.');  \n}\n\n\n// *******\n// Methods\n// *******\n\n// These are the methods that actually do the commits and undo and redo work\n// They would usually not be called directly -- but invoked using tx.undo() and tx.redo()\n// Although these methods are pretty large, we're including them on both client and server\n// because we want to maintain latency compensation on the client\n\nMeteor.methods({\n\n  '_meteorTransactionsProcess' : function (txid, description, items, context) {\n    \n    check(txid,String);\n    check(description,String);\n    check(items, Array);\n    check(context, Object); \n    \n    var cannotOverridePermissionCheck = true;\n    \n    return tx._processTransaction(txid, description, items, context, cannotOverridePermissionCheck);\n    \n  },\n  \n  '_meteorTransactionsUndo' : function (txid) {\n    check(txid,Match.OneOf(String,null,undefined));\n    if (tx.requireUser && !Meteor.userId()) {\n      console.log('You must be logged in to undo actions.');\n      return;\n    }\n    // Get the latest transaction done by this user and undo it\n    var expired = false;\n    var queuedItems = [];\n    var selector = (txid) ? { _id: txid} : {user_id: tx._userOrNull()};\n    var sorter = (txid) ? undefined : {sort: {lastModified: -1}, limit:1};\n    var lastTransaction = Transactions.find(_.extend(selector, {$or: [{undone: null}, {undone: {$exists: false}}], expired: {$exists: false}, state: \"done\"}), sorter).fetch()[0];\n    if (lastTransaction && typeof lastTransaction.items !== 'undefined') {\n      // Check that user still has permission to edit all these items\n      // Undo in reverse order\n      // e.g. Need to undo removes first, so that docs are available for undo updates if docs were updated before removal\n      if (tx._checkTransactionFields(lastTransaction.items, lastTransaction._id)) {\n        _.each(lastTransaction.items.reverse(), function (obj, index) {\n          if (obj.action === 'remove') {\n            if (!expired) {\n              if (obj.doc) {\n                // This doc is here because the original was removed\n                // First check for duplicates -- if there is one, the transaction has expired\n                if (tx.collectionIndex[obj.collection].find(obj.doc._id).count()) {\n                  expired = true;  \n                }\n                else {\n                  queuedItems.push(function () {\n                    tx.collectionIndex[obj.collection].insert(obj.doc);\n                  });\n                }\n              }\n              else {\n                // This was removed with softDelete\n                queuedItems.push(function () {\n                  tx.collectionIndex[obj.collection].update({_id: obj._id}, {$unset: {deleted: 1, transaction_id: lastTransaction._id}});\n                });\n              }\n            }\n          }\n          if (obj.action === 'update') {\n            if (!expired) {\n              if (typeof obj.inverse !== 'undefined' && obj.inverse.command && obj.inverse.data) {\n                var operation = {};\n                operation[obj.inverse.command] = tx._unpackageForUpdate(obj.inverse.data); // console.log('inverse operation:'+EJSON.stringify(operation));\n                queuedItems.push(function () {\n                  tx.collectionIndex[obj.collection].update({_id: obj._id}, operation);\n                  /* console.log(\"operation called:\"+EJSON.stringify(operation)); */\n                });\n              }\n            }\n          }\n          if (obj.action === 'insert') {\n            if (!expired) {\n              var sel = {_id: obj._id};\n              // This transaction check is in case the document has been subsequently edited -- in that case, we don't want it removed from the database completely\n              // Instead, we remove this transaction from the visible list by setting expired to true\n              sel.transaction_id = lastTransaction._id;\n              queuedItems.push(function () { tx.collectionIndex[obj.collection].remove(sel); } );\n              if (tx.collectionIndex[obj.collection].findOne({_id: obj._id, $and: [{transaction_id: {$exists: true}}, {transaction_id: {$ne: lastTransaction._id}}]})) {\n                // Transaction has expired\n                expired = true; // This is to tell the client that the transaction has expired and the undo was not executed\n              }\n            }\n          }\n        });\n        if (!expired) {\n          // Process queue\n          _.each(queuedItems,function (queuedItem, index) {\n            var fail = false;\n            try {\n              queuedItem.call();\n            }\n            catch (err) {\n              fail = true;    \n            }\n            if (!fail) {\n              tx._changeItemState({\n                txid: lastTransaction._id,\n                index: (queuedItems.length - 1) - index, // Because array has been reversed for undo\n                state: 'undone'\n              });\n            }\n          });\n        // After an undo, we need to update transaction document\n          Transactions.update({_id: lastTransaction._id}, {$set: {undone: ServerTime.date(), state: 'undone'}});\n        }\n      }\n      else {\n        // Non-empty transaction, but user has lost the permission to edit at least one of the items encompassed by the transaction\n        expired = true; \n      }\n      if (expired) {\n        // Flag this as expired in the db to keep it out of the user's undo/redo stack\n        Transactions.update({_id: lastTransaction._id}, {$set: {expired: true}});  \n      }\n    }\n    else if (lastTransaction) {\n      // Auto clean - this transaction is empty\n      Transactions.remove({_id: lastTransaction._id});\n    }\n    return expired; // If the function returns true, the undo failed\n  },\n  \n  '_meteorTransactionsRedo' : function (txid) {\n    check(txid,Match.OneOf(String, null, undefined));\n    if (tx.requireUser && !Meteor.userId()) {\n      console.log('You must be logged in to redo actions.');\n      return;\n    }\n    // Get the latest undone transaction by this user and redo it\n    var expired = false;\n    var queuedItems = [];\n    var selector = (txid) ? {_id: txid} : {user_id: tx._userOrNull()};\n    var sorter = (txid) ? undefined : {sort: {undone: -1}, limit: 1};\n    var lastUndo = Transactions.find(_.extend(selector, {undone: {$exists: true, $ne: null}, expired: {$exists: false}}), sorter).fetch()[0];\n    if (lastUndo && typeof lastUndo.items !== 'undefined') {\n      // Check that user still has permission to edit all these items\n      if (tx._checkTransactionFields(lastUndo.items, lastUndo._id)) {\n        _.each(lastUndo.items, function (obj, index) {\n          if (obj.action === \"remove\") {\n            if (obj.doc) {\n              // This document was removed using a hard delete the first time\n              // We'll hard delete again, making no attempt to save any modifications that have happened to the document in the interim\n              queuedItems.push(function () { tx.collectionIndex[obj.collection].remove({_id: obj._id})});\n            }\n            else {\n              queuedItems.push(function () { tx.collectionIndex[obj.collection].update({_id: obj._id}, {$set: {deleted: ServerTime.date(), transaction_id: lastUndo._id}})});\n            }\n          }\n          if (obj.action === \"update\") {\n            if (typeof obj.update !== 'undefined' && obj.update.command && obj.update.data) {\n              var operation = {};\n              operation[obj.update.command] = tx._unpackageForUpdate(obj.update.data);// console.log(operation);\n              queuedItems.push(function () { tx.collectionIndex[obj.collection].update({_id: obj._id}, operation); });\n            }\n          }\n          if (obj.action === \"insert\") {\n            if (!expired) {\n              if (!tx.collectionIndex[obj.collection].find({_id: obj._id}).count()) {\n                var newDoc = _.extend(obj.doc, {transaction_id: lastUndo._id,_id: obj._id});\n                queuedItems.push(function () { tx.collectionIndex[obj.collection].insert(newDoc) });\n              }\n              else {\n                // This is an edited doc that was not removed on last undo\n                // Transaction has expired\n                expired = true; // This is to tell the client that the transaction has expired and the redo was not executed\n              }\n            }\n          }\n          if (!expired) {\n              \n          }\n        });\n        if (!expired) {\n          // Process queue\n          _.each(queuedItems, function (queuedItem, index) {\n            var fail = false;\n            try {\n              queuedItem.call();\n            }\n            catch (err) {\n              fail = true;    \n            }\n            if (!fail) {\n              tx._changeItemState({\n                txid: lastUndo._id,\n                index: index,\n                state: 'done'\n              });\n            }\n          });\n          // After a redo, we need to update the transaction document\n          Transactions.update({_id: lastUndo._id}, {$unset: {undone: 1}, $set: {state: 'done'}}); // ,$set:{lastModified: ServerTime.date()} -- LEADS TO UNEXPECTED RESULTS\n        }\n      }\n      else {\n        // User no longer has permission to edit one of the items in this transaction\n        expired = true;  \n      }\n      if (expired) {\n        // Flag this transaction as expired to keep it out of the user's undo-redo stack\n        Transactions.update({_id: lastUndo._id}, {$set: {expired: true}});  \n      }\n    }\n    return expired; // If the function returns true, the redo failed\n  }\n  \n});\n\n\n// Wrap DB write operation methods\n// Wrapping technique shamelessly stolen from aldeed:collection2 codebase\n// (https://github.com/aldeed/meteor-collection2/blob/master/collection2.js) and modified for this package\n\n// backwards compatibility\nif (typeof Mongo === \"undefined\") {\n  Mongo = {};\n  Mongo.Collection = Meteor.Collection;\n}\n\n_.each(['insert', 'update', 'remove'], function (methodName) {\n  var _super = Mongo.Collection.prototype[methodName];\n  Mongo.Collection.prototype[methodName] = function () {\n    var self = this, args = _.toArray(arguments); // self is the Mongo.Collection instance\n    var optionsArg = (methodName === 'update') ? 2 : 1;\n    if (_.isObject(args[optionsArg]) && args[optionsArg].tx) {\n      args.unshift(self);\n      return tx[methodName].apply(tx,args);\n    }\n    return _super.apply(self, args);\n  };\n});\n\n// Here we ensure the the tx object is aware of the apps collections and can access them by name\n// we use dburles:mongo-collection-instances package to do this.\n// We also check for the presence of SimpleSchema and extend the schema of existing\n// collections to allow for the fields that transactions will add to documents\n\nMeteor.startup(function () {\n  Meteor.defer(function () {\n    \n    // Auto detect collections\n    tx.collectionIndex = (_.isEmpty(tx.collectionIndex)) ? _.reduce(Mongo.Collection.getAll(),function (memo,coll) { memo[coll.name] = coll.instance; return memo; },{}) : tx.collectionIndex;\n    \n    // Built in support for simple-schema/collection2\n    if (typeof SimpleSchema !== 'undefined') {\n      _.each(tx.collectionIndex,function (collection) {\n        if (_.isFunction(collection.simpleSchema) && collection.simpleSchema() !== null && collection._c2) {\n          collection.attachSchema({deleted: {type: Date, label: \"Deleted\", optional: true}, transaction_id: {type:String, label: \"transaction_id\", optional: true}, _id: {type: String, label: \"_id\", optional: true}});\n        }\n      });\n      if (_.isFunction(tx.Transactions.attachSchema)) {\n        var userPattern = {\n          type:String,\n          label:\"User Id\"\n        }\n        if (!tx.requireUser) {\n          userPattern.optional = true;    \n        }\n        var TransactionSchema = new SimpleSchema({\n          \"context\": {\n            type:Object,\n            label:\"Context\",\n            blackbox:true,\n            optional:true\n          },\n          \"description\": {\n            type:String,\n            label:\"Description\"\n          },\n          \"items\": {\n            type:[Object],\n            label:\"Items\",\n            blackbox:true,\n            optional:true\n          },\n          \"lastModified\": {\n            type:Date,\n            label:\"Timestamp\"\n          },\n          \"undone\": {\n            type:Date,\n            label:\"Undone\",\n            optional:true\n          },\n          \"user_id\": userPattern,\n          \"expired\": {\n            type:Boolean,\n            label:\"Expired\",\n            optional:true\n          },\n          \"state\": {\n            type:String,\n            label:\"state\"  \n          }\n        });\n        tx.Transactions.attachSchema(TransactionSchema);\n      }\n    }\n  });\n});","// *******************************\n// Transactions manager for Meteor\n// by Brent Abrahams\n// brent_abrahams@yahoo.com\n// MIT Licence 2015\n// *******************************\n  \n// This script makes an attempt to restore db state after a break during a transaction\n\nMeteor.startup(function() {\n  \n  // Add a function to purge transactions that\n  // are never going to be completed or rolled back successfully\n  \n  Transact.prototype.purgeIncomplete = function () {\n    Transactions.remove({state: {$nin: ['done', 'undone']}});\n  }\n  \n  Transact.prototype._repairAllIncomplete = function (mode) {\n    if (_.contains(['complete', 'rollback'], mode)) {\n      var sortDirection = (mode === 'rollback') ? -1 : 1;\n      Transactions.find({state: 'pending'}, {sort: {lastModified: sortDirection}}).forEach(function (transaction) {\n        tx._repairIncomplete(transaction, mode); \n      });\n    }\n  }\n  \n  // Attempts to repair incomplete transactions\n  // `transaction` is a single transaction document\n  // `type` is a string -- possible values: \"complete\", \"rollback\"\n  \n  Transact.prototype._repairIncomplete = function (transaction, mode) {\n    tx.log('Attempting to repair transaction by ' + mode + ':', transaction);\n    // Set the state of this transaction to the mode until it is complete\n    if (!Transactions.update({_id: transaction._id}, {$set: {state: mode}})) {\n      tx.log('Unable to ' + mode + ' transaction');\n      return;    \n    }\n    var items = (mode === 'rollback') ? transaction.items.reverse() : transaction.items;\n    var failed = false;\n    var targetState = (mode === 'rollback') ? 'undone' : 'done';\n    // From a security standpoint, it would be nice to put\n    // var failed = tx._checkTransactionFields(items, transaction._id);\n    // but we can't guarantee that the user-defined permission checks\n    // that `tx._checkTransactionFields` invokes\n    // won't be dependent upon Meteor.user() or Meteor.userId()\n    // which, of course, won't be defined when called from this context.\n    // We are trusting that this package has not let anything into the `transactions`\n    // collection that shouldn't be there.\n    _.each(items, function (item, index) {\n      // Note, at this stage we are only supporting repair of incomplete commits\n      // TODO -- this could be extended to include incomplete undos or redos\n      if (!((mode === 'complete' && item.state === 'pending')\n         || (mode === 'rollback' && item.state === 'done'))) {\n        // Either we don't deal with this state\n        // Or the action we wanted to do is already done\n        tx.log('Skipped \"' + mode + ' ' + item.action + '\" as it is ' + item.state + ':', item);\n        return;  \n      }\n      Collection = tx.collectionIndex[item.collection];\n      try {\n        switch (item.action) {\n          case 'insert' :\n            switch (mode) {\n              case 'complete' :\n                if (!Collection.insert(item.newDoc)) {\n                  failed = true;    \n                }\n                break;\n              case 'rollback' :\n                if (!Collection.remove({_id: item._id})) {\n                  failed = true;    \n                }\n                break;    \n            }\n          case 'remove' :\n            switch (mode) {\n              case 'complete' :\n                if (item.hardDelete) {\n                  // We are storing the document as it was then, not as it is now\n                  // to preserve some consistency in case of later updates\n                  if (!Collection.remove({_id: item._id})) {\n                     failed = true;  \n                  }\n                }\n                else {\n                  if (!Collection.update({_id: item._id}, {$set: {deleted: ServerTime.date(), transaction_id: transaction._id}})) {\n                    failed = true;  \n                  }\n                }\n                break;\n              case 'rollback' :\n                if (item.hardDelete) {\n                  if (!Collection.insert(item.doc)) {\n                    failed = true;  \n                  }\n                }\n                else {\n                  /*if (!Collection.update({_id: item._id}, {$unset: {deleted: 1, transaction_id: 1}})) {\n                    failed = true;  \n                  }*/\n                  // Can't do above as those fields might already be unset, resulting in a 0 being returned\n                  // Should just use callbacks with error checks\n                  Collection.update({_id: item._id}, {$unset: {deleted: 1, transaction_id: 1}});\n                }\n                break;    \n            }\n          case 'update' :  \n            switch (mode) {\n              case 'complete' : \n                if (typeof item.update !== 'undefined' && item.update.command && item.update.data) {\n                  var operation = {};\n                  operation[item.update.command] = tx._unpackageForUpdate(item.update.data);\n                  /*if (!Collection.update({_id: item._id}, operation)) {\n                    failed = true;  \n                  }*/\n                  Collection.update({_id: item._id}, operation);\n                }\n                break;\n              case 'rollback' :\n                if (typeof item.inverse !== 'undefined' && item.inverse.command && item.inverse.data) {\n                  var operation = {};\n                  operation[item.inverse.command] = tx._unpackageForUpdate(item.inverse.data);\n                  /*if (!Collection.update({_id: item._id}, operation)) {\n                    failed = true;  \n                  }*/\n                  Collection.update({_id: item._id}, operation);\n                }\n                break;   \n            }\n        }\n      }\n      catch (err) {\n        tx.log(err);\n        failed = true;  \n      }\n      if (!failed) {\n        // Need to change the state of this particular action\n        var modifier = {};\n        // Array is reversed for a rollback, so index needs to be calculated from other end of array\n        var trueIndex = (mode === 'rollback') ? (items.length - 1) - index : index;\n        modifier[\"items.\" + trueIndex + \".state\"] = targetState; \n        Transactions.update({_id: transaction._id}, {$set: modifier});\n      }\n    });\n    // Record this whole transaction as completed\n    if (!failed) {\n      var modifier = {};\n      if (mode === 'rollback') {\n        modifier[\"$set\"] = {state: \"undone\", undone: ServerTime.date()};\n      }\n      else {\n        modifier[\"$unset\"] = {undone: 1};\n        modifier[\"$set\"] = {state: \"done\"};\n      }\n      Transactions.update({_id: transaction._id}, modifier);\n      tx.log('Transaction repaired by ' + mode + ':', Transactions.findOne({_id: transaction._id}));\n    }\n    else {\n      tx.log('Could not ' + mode + ' transaction:', Transactions.findOne({_id: transaction._id}));\n    }\n  }\n\n  Meteor.defer(function() {\n      \n    // Give time for everything else to be set up by the transactions-common.js script\n    tx._repairAllIncomplete(tx.selfRepairMode);\n\n  });\n\n});"]}